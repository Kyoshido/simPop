% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{ipu_step}
\alias{ipu_step}
\alias{ipu_step_ref}
\alias{ipu_step}
\alias{ipu_step_f}
\title{Perform one step of iterative proportional updating}
\usage{
ipu_step_ref(w, classes, targets)

ipu_step(w, classes, targets)

ipu_step_f(w, classes, targets)
}
\arguments{
\item{w}{An numeric vector of weights. All entries should be positive.}

\item{classes}{A factor variable. Must have the same length as \code{w}.}

\item{targets}{key figure to target with the ipu scheme. A numeric verctor of the same length as \code{levels(classes)}.}
}
\description{
C++ routine to invoke a single iteration of the IPU scheme. Targets and classes are assumed to be one dimensional.
\code{ipu_step} returns the adjusted weigth verctor while \code{ipu_step_ref} updates the input \code{w} by reference.
}
\examples{

## create random data
nobs <- 10
classLabels <- letters[1:3]
dat = data.frame(
  weight = exp(rnorm(nobs)),
  household = factor(sample(classLabels, nobs, replace = TRUE))
)
dat

## create targets (same lenght as classLabels!)
targets <- 3:5

## calculate weights
new_weight <- ipu_step(dat$weight, dat$household, targets)
cbind(dat, new_weight)

## check solution
xtabs(new_weight ~ dat$household)

## calculate weights "by reference"
ipu_step_ref(dat$weight, dat$household, targets)
dat

}
